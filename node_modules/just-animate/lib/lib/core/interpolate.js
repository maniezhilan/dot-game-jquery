Object.defineProperty(exports, "__esModule", { value: true });
var just_curves_1 = require("just-curves");
var inspect_1 = require("../utils/inspect");
var functional_1 = require("../utils/functional");
var lists_1 = require("../utils/lists");
function findEndIndex(ns, n) {
    var ilen = ns.length;
    for (var i = 0; i < ilen; i++) {
        if (ns[i] > n) {
            return i;
        }
    }
    return ilen - 1;
}
var getEasing = functional_1.memoize(just_curves_1.cssFunction);
var getInterpolator = functional_1.memoize(function (fn) { return functional_1.memoize(fn); });
function interpolate(l, r, o) {
    return l + (r - l) * o;
}
exports.interpolate = interpolate;
function fallbackInterpolator(l, r, o) {
    return o < 0.5 ? l : r;
}
function interpolator(duration, keyframes) {
    var times = keyframes.map(function (k) { return k.offset * duration; });
    lists_1.all(keyframes, function (k) {
        var isSimple = !inspect_1.isFunction(k.interpolate);
        k.simpleFn = isSimple;
        k.interpolate = !isSimple
            ? getInterpolator(k.interpolate)
            : inspect_1.isNumber(k.value)
                ? interpolate
                : fallbackInterpolator;
    });
    return function (timelineOffset) {
        var absTime = duration * timelineOffset;
        var r = findEndIndex(times, absTime);
        var l = r ? r - 1 : 0;
        var rt = times[r];
        var lt = times[l];
        var lk = keyframes[l];
        var time = (absTime - lt) / (rt - lt);
        var progression = lk.easing ? getEasing(lk.easing)(time) : time;
        if (lk.simpleFn) {
            return lk.interpolate(lk.value, keyframes[r].value, progression);
        }
        return lk.interpolate(lk.value, keyframes[r].value)(progression);
    };
}
exports.interpolator = interpolator;
