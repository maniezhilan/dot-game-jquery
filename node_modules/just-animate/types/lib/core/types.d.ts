export interface WebPropertyOptions {
    [name: string]: PropertyResolver<PropertyValue> | PropertyResolver<PropertyValue>[];
}
export interface PropertyOptions {
    [name: string]: PropertyValueOptions | PropertyResolver<PropertyValue> | PropertyResolver<PropertyValue>[];
}
export interface PropertyValueOptions {
    value: PropertyResolver<PropertyValue> | PropertyResolver<PropertyValue>[];
    easing?: string;
    interpolate?: Interpolator | string;
}
export interface Dictionary<T> {
    [prop: string]: T;
}
export interface SetOptions {
    [name: string]: PropertyResolver<string | number>;
}
export interface Interpolator {
    (left: any, right: any): (offset: number) => any;
}
export interface Keyframe {
    offset: number;
    value: string | number;
    easing: string;
    interpolate: Function;
    simpleFn?: boolean;
}
export declare type AnimationTarget = any;
export declare type KeyframeValue = string | number;
export interface PropertyFunction<T> {
    (target: any, index: number, len: number): T;
}
export interface PropertyObject {
    value: string | number;
    offset?: number;
    easing?: string;
    interpolate?: Interpolator | string;
}
export declare type PropertyValue = string | number | PropertyObject;
export declare type PropertyResolver<T> = T | PropertyFunction<T>;
export interface AnimationController {
    cancel(): void;
    update(time: number, playbackRate: number, isActive: boolean): void;
}
export interface AnimationPlayer extends AnimationController {
    config: TargetConfiguration;
    from: number;
    to: number;
}
export interface JustAnimatePlugin {
    name: string;
    onWillAnimate?: {
        (target: TargetConfiguration, effects: PropertyEffects, propToPlugin?: Dictionary<string>): void;
    };
    animate(effect: Effect): AnimationController;
    getValue(target: AnimationTarget, key: string): string | number;
}
export interface PropertyKeyframe {
    easing: string;
    time: number;
    prop: string;
    plugin: string;
    index: number;
    value: string | number;
    interpolate: Interpolator | string;
}
export interface PropertyEffects {
    [name: string]: PropertyEffect[];
}
export interface PropertyEffect {
    offset: number;
    easing: string;
    value: string | number;
    interpolate: Interpolator;
}
export interface TargetConfiguration {
    target: AnimationTarget;
    targetLength: number;
    easing: string;
    from: number;
    to: number;
    endDelay: number;
    duration: number;
    stagger: number;
    propNames: string[];
    keyframes: PropertyKeyframe[];
}
export interface BaseAnimationOptions {
    targets: AnimationTarget | AnimationTarget[];
    delay?: PropertyResolver<number>;
    easing?: string;
    endDelay?: PropertyResolver<number>;
    props?: PropertyOptions;
    stagger?: number;
    web?: WebPropertyOptions;
}
export interface BaseSetOptions {
    targets: AnimationTarget | AnimationTarget[];
    at?: number;
    easing?: string;
    props?: SetOptions;
    web?: SetOptions;
}
export interface AddAnimationOptions extends BaseAnimationOptions {
    from?: number;
    to?: number;
    duration?: number;
}
export interface AnimationOptions {
    from: number;
    to: number;
    easing?: string;
    targets: AnimationTarget[];
    stagger?: number;
    delay?: PropertyResolver<number>;
    endDelay?: PropertyResolver<number>;
    props?: PropertyOptions;
    web?: WebPropertyOptions;
}
export interface Effect {
    target: AnimationTarget;
    plugin: string;
    prop: string;
    keyframes: Keyframe[];
    to: number;
    from: number;
}
export interface References {
    [name: string]: any;
}
export interface TimelineOptions {
    id?: string;
    references?: References;
}
export declare type TimelineEvent = 'cancel' | 'config' | 'finish' | 'pause' | 'reverse' | 'update' | 'play';
export interface IReducerContext {
    events: string[];
    needUpdate: TargetConfiguration[];
    destroyed?: boolean;
    trigger(eventName: string): void;
    dirty(config: TargetConfiguration): void;
}
export interface IReducer {
    (model: ITimelineModel, data: any, ctx: IReducerContext): void;
}
export interface ITimelineEventListener {
    (data: any): void;
}
export interface IStore {
    state: ITimelineModel;
    subs: Record<TimelineEvent, ITimelineEventListener[]>;
}
export interface ITimelineModel {
    id: string;
    configs: TargetConfiguration[];
    duration: number;
    cursor: number;
    rate: number;
    refs: References;
    repeat: number;
    round: number;
    state: number;
    time: number;
    yoyo: boolean;
    players: AnimationPlayer[];
    destroy?: boolean;
}
export interface PlayOptions {
    repeat?: number;
    alternate?: boolean;
    destroy?: boolean;
}
export interface ITimeline {
    currentTime: number;
    duration: number;
    playbackRate: number;
    state: number;
    id?: string;
    add(opts: AddAnimationOptions | AddAnimationOptions[]): this;
    animate(opts: AddAnimationOptions | AddAnimationOptions[]): this;
    destroy(): void;
    fromTo(from: number, to: number, options: BaseAnimationOptions | BaseAnimationOptions[]): this;
    sequence(this: ITimeline, seqOptions: AddAnimationOptions[]): this;
    set(options: BaseSetOptions | BaseSetOptions[]): this;
    cancel(): this;
    finish(): this;
    on(eventName: TimelineEvent, listener: (time: number) => void): this;
    once(eventName: TimelineEvent, listener: (time: number) => void): this;
    off(eventName: TimelineEvent, listener: (time: number) => void): this;
    pause(): this;
    play(options?: PlayOptions): this;
    reverse(): this;
    seek(time: number): this;
}
