import { uuid } from './utils/uuid';
import { all } from './utils/lists';
import { CANCEL, DESTROY, FINISH, PAUSE, UPDATE_RATE, UPDATE_TIME, REVERSE, PLAY, APPEND, SET, INSERT } from './actions';
import { dispatch, addState, getState, on, off } from './store';
const timelineProto = {
    get state() {
        return getState(this.id).state;
    },
    get duration() {
        return getState(this.id).duration;
    },
    get currentTime() {
        return getState(this.id).time;
    },
    set currentTime(time) {
        dispatch(UPDATE_TIME, this.id, time);
    },
    get playbackRate() {
        return getState(this.id).rate;
    },
    set playbackRate(rate) {
        dispatch(UPDATE_RATE, this.id, rate);
    },
    add(opts) {
        dispatch(APPEND, this.id, opts);
        return this;
    },
    animate(opts) {
        dispatch(APPEND, this.id, opts);
        return this;
    },
    fromTo(from, to, options) {
        all(options, options2 => {
            options2.to = to;
            options2.from = from;
        });
        dispatch(INSERT, this.id, options);
        return this;
    },
    cancel() {
        dispatch(CANCEL, this.id);
        return this;
    },
    destroy() {
        dispatch(DESTROY, this.id);
    },
    finish() {
        dispatch(FINISH, this.id);
        return this;
    },
    on(name, fn) {
        on(this.id, name, fn);
        return this;
    },
    once(eventName, listener) {
        const self = this;
        self.on(eventName, function s(time) {
            self.off(eventName, s);
            listener(time);
        });
        return self;
    },
    off(name, fn) {
        off(this.id, name, fn);
        return this;
    },
    pause() {
        dispatch(PAUSE, this.id);
        return this;
    },
    play(options) {
        dispatch(PLAY, this.id, options);
        return this;
    },
    reverse() {
        dispatch(REVERSE, this.id);
        return this;
    },
    seek(time) {
        dispatch(UPDATE_TIME, this.id, time);
        return this;
    },
    sequence(seqOptions) {
        all(seqOptions, opt => dispatch(APPEND, this.id, opt));
        return this;
    },
    set(opts) {
        dispatch(SET, this.id, opts);
        return this;
    }
};
export function timeline(opts) {
    const t1 = Object.create(timelineProto);
    opts = opts || {};
    opts.id = opts.id || uuid();
    t1.id = opts.id;
    addState(opts);
    return t1;
}
